<!doctype html>

<body>
<div id = 'user_header'>
    Welcome!
</div>
</body>


<div id="instructions_html" style="visibility:hidden">
    <text style="font-weight:bold; font-size:large">Thank you for your interest and contributing to research at at MIT!</text>

    <ul>
        <li>Please use a laptop or desktop with <b>Google Chrome</b> or <b>Firefox</b> to work on this HIT as intended.
        <li>You will be completing several trials. On each trial, you'll view a rapidly flashed image of an object.
        <li><b>Your task</b> is to figure out which button to press (either "F" or "J" on your keyboard) after viewing a particular object.
        <li>If you made a correct choice, you will see a <text style="color:green; font-style:italic">green</text> square pop up. <b>You will also increase your bonus</b>, so give it your best shot!
        <li>If you made an incorrect choice, you will see a <text style="color:black; font-style:italic">black</text> square instead, and have to wait a bit before you can try again.
        <li>To actually start a trial, press the spacebar. The image will immediately appear, so be ready!
        <li>If you encounter a bug (for example, the task freezing), please contact us and let us know. You will receive compensation for your time.
    </ul>
    <p>
        <text style="color:#7A7A7A; font-size:smaller; font-style:italic">If you cannot meet these requirements or if
            doing so could cause discomfort or injury, do not accept this HIT. If you are uncomfortable during the HIT, please feel free return it.
            You will not be penalized in any way.
        </text>
    </p>
</div>

<head>


    <title>DiCarlo Lab - Mechanical Turk</title>

    <script>
////////// IMPORT from /common/canvas.js//////////
function get_screen_dims(){
    var h = window.screen.height;
    var w = window.screen.width;
    return [h, w]
}

function get_window_dims() {
    // Reference: https://www.w3schools.com/js/js_window.asp
    var w = window.innerWidth
        || document.documentElement.clientWidth
        || document.body.clientWidth;

    var h = window.innerHeight
        || document.documentElement.clientHeight
        || document.body.clientHeight;

    return [h, w]
}


function infer_canvas_size() {
    // Present the canvases at 85% of the smallest screen dimension
    var [screen_height, screen_width] = get_screen_dims();
    var screen_margin = 0.25;
    return Math.round(Math.min(screen_height, screen_width)) * (1 - screen_margin);
}

function create_canvas(canvas_id, width, height){
    /*
    Creates and returns a canvas with id canvas_id
     */

    var use_image_smoothing = true;

    // Create canvas and assign name
    var canvasobj = document.createElement('canvas');
    canvasobj.id = canvas_id;

    // Detect the pixel ratio of the subject's device
    var context = canvasobj.getContext('2d');

    var devicePixelRatio = window.devicePixelRatio || 1;
    var backingStoreRatio = context.webkitBackingStorePixelRatio ||
        context.mozBackingStorePixelRatio ||
        context.msBackingStorePixelRatioproportion2pixels ||
        context.oBackingStorePixelRatio ||
        context.backingStorePixelRatio || 1; // /1 by default for chrome?

    var _ratio = devicePixelRatio / backingStoreRatio;

    // Set the dimensions of the canvas
    canvasobj.width = width * _ratio;
    canvasobj.height = height * _ratio;

    // Center canvas: https://stackoverflow.com/questions/5127937/how-to-center-canvas-in-html5
    canvasobj.style.padding = 0;
    canvasobj.style.margin = 'auto';
    canvasobj.style.display = "block"; //visible
    canvasobj.style.position = 'absolute';
    canvasobj.style.top = 0;
    canvasobj.style.bottom = 0;
    canvasobj.style.left = 0;
    canvasobj.style.right = 0;
    canvasobj.style.border = '1px dotted #E6E6E6';
    canvasobj.style.width = width + 'px'; // Set browser canvas display style to be workspace_width
    canvasobj.style.height = height + 'px';

    // Set background
    context.fillStyle = "#7F7F7F";
    context.fillRect(0, 0, canvasobj.width, canvasobj.height);

    // Set image smoothing
    context.imageSmoothingEnabled = use_image_smoothing;

    if (_ratio !== 1) {
        context.scale(_ratio, _ratio)
    }

    // Append to document body
    document.body.appendChild(canvasobj);
    return canvasobj
}

function set_canvas_level(canvas, z){
    /*
    canvas: Canvas object reference
    z: integer
     */
    canvas.style.zIndex = z.toString();
}

async function draw_dot_with_text(canvas, text, xcentroid_pixel, ycentroid_pixel, diameter_pixel, dot_color, alpha, ) {
    var context = canvas.getContext('2d');

    // Apply alpha to the dot
    if (alpha !== undefined) {
        // https://stackoverflow.com/questions/10487882/html5-change-opacity-of-a-draw-rectangle/17459193
        context.globalAlpha = alpha
    }

    context.beginPath();
    context.arc(xcentroid_pixel, ycentroid_pixel, diameter_pixel / 2, 0 * Math.PI, 2 * Math.PI);
    context.fillStyle = dot_color;
    context.fill();

    var nLetters = text.length;
    if (nLetters > 0){
        var letterSize = Math.min((diameter_pixel*2) / (nLetters + 0.5), 40);
        context.font = letterSize.toString() + "px Arial";
        context.fillStyle = "gray";
        context.textAlign = "center";
        context.textBaseline = "middle";
        context.fillText(text, xcentroid_pixel, ycentroid_pixel);
    }

    // So further calls to this canvas context are not necessarily alpha'd out.
    context.globalAlpha = 1
}

async function draw_rectangle(canvas, xcentroid, ycentroid, width_pixels, height_pixels, color, alpha) {
    var context = canvas.getContext('2d');
    context.fillStyle = color;
    context.globalAlpha = alpha;
    var width = parseFloat(canvas.style.width);
    var height = parseFloat(canvas.style.height);
    context.fillRect(xcentroid - width_pixels / 2, ycentroid - height_pixels / 2, width_pixels, height_pixels);
    context.fill();
    context.globalAlpha = 1
}

async function draw_text(canvas, string, font, color, x, y, align){
    var ctx = canvas.getContext("2d");
    ctx.font = font;
    ctx.fillStyle = color;
    ctx.textAlign = align;
    ctx.textBaseline = 'middle';
    ctx.fillText(string, x, y);
    ctx.globalAlpha = 1
}

async function draw_image(canvas, image, xcentroid_pixel, ycentroid_pixel, diameter_pixels) {
    /*
    Draws an image on the canvas.

    canvas: a reference to a Canvas object.
    image: an image blob.
    xcentroid_pixel: () with respect to canvas coordinates (x = 0 at left; positive direction is rightward)
    ycentroid_pixel: () with respect to canvas coordinates (y = 0 at top; positive direction is downward)
    diameter_pixels: () the size of the drawn image's longest dimension (either width or height).
     */
    var nativeWidth = image.naturalWidth;
    var nativeHeight = image.naturalHeight;
    let drawHeight, drawWidth;

    if (nativeHeight > nativeWidth) {
        drawHeight = diameter_pixels;
        drawWidth = diameter_pixels * nativeWidth / nativeHeight
    } else {
        drawWidth = diameter_pixels;
        drawHeight = diameter_pixels * nativeHeight / nativeWidth
    }

    // Place left corner of image
    var original_left_start = xcentroid_pixel - diameter_pixels / 2;
    var original_top_start = ycentroid_pixel - diameter_pixels / 2;

    var context = canvas.getContext('2d');
    await context.drawImage(image, original_left_start, original_top_start, drawWidth, drawHeight);
}

function display_canvas_sequence(canvas_sequence, t_durations) {
    /*
    Input arguments:
        canvas_sequence: Array of references to DOM canvases
        t_durations: Array of floats / integers; in units of milliseconds.
                     The amount of time that must elapse before the next frame is shown.
                     In the case of the last frame, this is the amount of time that is "blocked" before the promise resolves.

     This function immediately displays the canvases given in canvas_sequence.

     The last canvas in the sequence is kept "on" once this function is concluded.

     The function returns a promise that resolves when the sequence has concluded. The resolved promise returns
     an Array with performance.now() timestamps corresponding to the draw time of each canvas.
    */

    // Instantiate Promise which will resolve when the sequence is done
    var resolveFunc;
    var errFunc;
    var promise_done_with_sequence = new Promise(function (resolve, reject) {
        resolveFunc = resolve;
        errFunc = reject;
    }).then();

    const nframes = canvas_sequence.length;
    var frame_timestamps = [];
    var i_canvas_next = 0;
    var on_first_call = true;
    var timestamp_draw = undefined;
    var epsilon = (1/60 * 1000) * 0.4; // If a frame has been reported to be shown for at least (trequested - epsilon), go to the next frame. The alternative is that the frame is shown for longer than requested (trequested + frame_period).

    function check_frame(timestamp) {
        /*
        timestamp: a DOMHighResTimeStamp instance, similar to the number given by performance.now(). It is in milliseconds.
         */

        if (on_first_call === true){
            on_first_call = false;
            set_canvas_level(canvas_sequence[i_canvas_next], 100);
            i_canvas_next++;
            timestamp_draw = timestamp;
            frame_timestamps.push(performance.now());
        }
        else{
            var time_elapsed = timestamp - timestamp_draw;
            var canvas_duration_fulfilled = time_elapsed >= (t_durations[i_canvas_next - 1] - epsilon);

            if ((canvas_duration_fulfilled) && (i_canvas_next < nframes)){
                set_canvas_level(canvas_sequence[i_canvas_next], 100);
                set_canvas_level(canvas_sequence[i_canvas_next-1], 0);
                i_canvas_next++;
                timestamp_draw = timestamp;
                frame_timestamps.push(performance.now())
            }
        }

        // On last canvas
        var on_last_canvas = i_canvas_next === nframes;
        if (on_last_canvas === true){
            // Time remaining on this canvas has elapsed
            if ((timestamp - timestamp_draw) >= t_durations[i_canvas_next-1]){
                resolveFunc(frame_timestamps)
            }
            else{
                window.requestAnimationFrame(check_frame);
            }
        }
        // More canvases to draw
        else{
            window.requestAnimationFrame(check_frame)
        }
    }

    window.requestAnimationFrame(check_frame);
    return promise_done_with_sequence
}



////////// IMPORT from /common/image_loading.js//////////
const __check_image_download_successful = path =>
    new Promise((resolve) => {
        const img = new Image();
        img.onload = () => resolve({img, path, status: 'ok'});
        img.onerror = () => resolve({path, status: 'error'});
        img.src = path;
    });


class ImageBufferClass {
    constructor() {
        this.cache_dict = {}; // url:image data
        this.cache_members = []; // earliest image_path -> latest image_path
    }

    async get_by_url(url) {
        // url: string
        // Requested image not in buffer. Add it, then return.
        if (url in this.cache_dict) {
            return this.cache_dict[url]
        } else if (!(url in this.cache_dict)) {
            await this.download_image(url);
            return this.cache_dict[url]
        }
        console.log('Downloaded image at', url)
    }

    async remove_image_from_cache(url) {
        // Currently unused
        try {
            window.URL.revokeObjectURL(this.cache_dict[url].src);
            delete this.cache_dict[url];
        } catch (error) {
            console.log('removal of', filename, 'failed with:', error)
        }
    }

    async download_image(url) {
        // url: string
        try {
            if (!(url in this.cache_dict)) {
                this.cache_dict[url] = await this._load_image_core(url);
                this.cache_members.push(url);
            }
        } catch (error) {
            console.error("cache_these_images failed with error:", error)
        }
    }

    async _load_image_core(url) {
        var img = await __check_image_download_successful(url);
        if (img.status === 'ok'){
            return img.img
        }
        else{
            console.warn('error loading image at', url);
            return 'image_failure'
        }
    }
}


////////// IMPORT from /common/instructions_splash.js//////////
function run_instructions(instructions_html, disable_button){
    /*
    instructions_html: String
    disable_button: boolean

    Creates and displays a div (at z-level 103) with a constituent span which displays the instructions_html.
    A button is created that will close the div.
    If disable_button === true, the button is disabled.
    */

    var div = document.createElement("div");
    div.setAttribute("id", 'instructions_div');
    div.style.position = "fixed";
    div.style.top = "50%";
    div.style.left = "50%";
    div.style.height = "50%";
    div.style.width = "70%";
    div.style.transform = "translate(-50%, -50%)";
    div.style.display = 'flex';
    div.style['align-items'] = 'center';
    div.style['flex-direction'] = 'column';
    div.style['font-size'] = '14px';
    div.style['z-index'] = '103';
    div.style['font-family'] = '\'Helvetica Neue\', serif';
    div.style['text-align'] = 'left';
    div.style.color = '#4B4B4B';
    div.style['background-color'] = '#E4E4E4';
    div.style.visibility = 'visible';
    div.style['border-radius'] = '8px';
    div.style['border-color'] = '#E6E6E6';
    div.style['border-style'] = 'solid';
    div.style['padding-right'] = '1%';
    div.style['padding-left'] = '1%';

    var span = document.createElement('span');
    span.innerHTML = instructions_html;
    div.appendChild(span);

    var button = document.createElement('button');


    var resolve_func;
    function _user_clicked(){
        div.style.display = 'none';
        resolve_func()
    }
    button.style.position = "fixed";
    button.style.top = '95%';
    button.onclick = _user_clicked;
    button.disabled = disable_button;
    if (disable_button === true){
        button.innerHTML = 'Preview Mode. Accept the HIT if you would like to participate!'
    }
    else{
        button.innerHTML = 'I understand the instructions and would like to begin the task.'
    }

    div.appendChild(button);

    document.body.appendChild(div);
    //document.getElementById("main").appendChild(div);

    return new Promise(function(resolve, reject){
        resolve_func = resolve;
    })

}

////////// IMPORT from /common/math_utils.js//////////
class MathUtils{
    constructor() {}

    static random_choice(choices){
        var i_index = Math.floor(Math.random() * choices.length);
        return choices[i_index];
    }

    static permute(array) {
        // https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array/46161940
        var currentIndex = array.length, temporaryValue, randomIndex;

        // While there remain elements to shuffle...
        while (0 !== currentIndex) {

            // Pick a remaining element...
            randomIndex = Math.floor(Math.random() * currentIndex);
            currentIndex -= 1;

            // And swap it with the current element.
            temporaryValue = array[currentIndex];
            array[currentIndex] = array[randomIndex];
            array[randomIndex] = temporaryValue;
        }

        return array;
    }

    static mean(array) {
        let i = 0, sum = 0, len = array.length;

        while (i < len) {
            sum = sum + array[i++];
        }

        return sum / len;
    }

    static multinomial(probs){
        /*
        probs: [nchoices] Array containing possibly unnormalized probabilities for each position. Assumes these values are all nonnegative.
        returns: () an index
         */
        const nchoices = probs.length;

        // Early exit, only one choice
        if(nchoices===1){
            return 0
        }

        // Normalize probabilities
        var total_mass = 0;
        for (let i = 0; i < nchoices; i++){
            total_mass = total_mass + probs[i]
        }
        var probs_normalized = [...probs];
        for (let i = 0; i < nchoices; i++){
            probs_normalized[i] = probs_normalized[i] / total_mass;
        }

        // Calculate the "right" edge of each bin in the range [0, 1]
        var cum_probs = [];
        var cur = 0;
        for (let i = 0; i < nchoices; i++){
            cum_probs.push(cur + probs_normalized[i]);
            cur = cur+probs_normalized[i]
        }
        const sample = Math.random();
        for (let i = 0; i < nchoices; i++){
            if (sample < cum_probs[i]){
                return i
            }
        }

        return (nchoices - 1)
    }
}

// The following snippet randomly initializes the seed for all subsequent Math.random() calls:
// https://github.com/davidbau/seedrandom
!function (a, b, c, d, e, f, g, h, i) {
    function j(a) {
        var b, c = a.length, e = this, f = 0, g = e.i = e.j = 0, h = e.S = [];
        for (c || (a = [c++]); d > f;) h[f] = f++;
        for (f = 0; d > f; f++) h[f] = h[g = s & g + a[f % c] + (b = h[f])], h[g] = b;
        (e.g = function (a) {
            for (var b, c = 0, f = e.i, g = e.j, h = e.S; a--;) b = h[f = s & f + 1], c = c * d + h[s & (h[f] = h[g = s & g + b]) + (h[g] = b)];
            return e.i = f, e.j = g, c
        })(d)
    }

    function k(a, b) {
        var c, d = [], e = typeof a;
        if (b && "object" == e) for (c in a) try {
            d.push(k(a[c], b - 1))
        } catch (f) {
        }
        return d.length ? d : "string" == e ? a : a + "\0"
    }

    function l(a, b) {
        for (var c, d = a + "", e = 0; e < d.length;) b[s & e] = s & (c ^= 19 * b[s & e]) + d.charCodeAt(e++);
        return n(b)
    }

    function m(c) {
        try {
            return o ? n(o.randomBytes(d)) : (a.crypto.getRandomValues(c = new Uint8Array(d)), n(c))
        } catch (e) {
            return [+new Date, a, (c = a.navigator) && c.plugins, a.screen, n(b)]
        }
    }

    function n(a) {
        return String.fromCharCode.apply(0, a)
    }

    var o, p = c.pow(d, e), q = c.pow(2, f), r = 2 * q, s = d - 1, t = c["seed" + i] = function (a, f, g) {
        var h = [];
        f = 1 == f ? {entropy: !0} : f || {};
        var o = l(k(f.entropy ? [a, n(b)] : null == a ? m() : a, 3), h), s = new j(h);
        return l(n(s.S), b), (f.pass || g || function (a, b, d) {
            return d ? (c[i] = a, b) : a
        })(function () {
            for (var a = s.g(e), b = p, c = 0; q > a;) a = (a + c) * d, b *= d, c = s.g(1);
            for (; a >= r;) a /= 2, b /= 2, c >>>= 1;
            return (a + c) / b
        }, o, "global" in f ? f.global : this == c)
    };
    if (l(c[i](), b), g && g.exports) {
        g.exports = t;
        try {
            o = require("crypto")
        } catch (u) {
        }
    } else h && h.amd && h(function () {
        return t
    })
}(this, [], Math, 256, 6, 52, "object" == typeof module && module, "function" == typeof define && define, "random");
Math.seedrandom();


////////// IMPORT from /common/mturk_submission.js//////////
class mechanical_turk_util_functions{
    static async submit_data(assignmentId, sandbox_mode, data_obj){
        /*
        assignmentId: str
        sandbox_mode: bool
        data_obj: JSON-like object

        Submits data to Mechanical Turk servers, and concludes the assignment for the subject.
        Per AWS documentation, we are required to include the assignmentId. Other fields are optional.
         */

        // Check to see if we should submit to the Mechanical Turk Sandbox server
        var external_question_submission_url = 'https://www.mturk.com/mturk/externalSubmit';
        if (sandbox_mode === true){
            external_question_submission_url = "https://workersandbox.mturk.com/mturk/externalSubmit";
        }

        // Create the submission form
        var submission_form = document.createElement("form");
        document.body.appendChild(submission_form);
        submission_form.setAttribute("method", "post");
        submission_form.setAttribute("action", external_question_submission_url);
        submission_form.style = "display: none;";

        // Attach inputs to the submission form
        var submission_data_input = document.createElement("input");
        submission_data_input.setAttribute("name", 'submission_data');
        submission_form.appendChild(submission_data_input);

        var assignmentId_input = document.createElement("input");
        assignmentId_input.setAttribute("name", 'assignmentId');
        submission_form.appendChild(assignmentId_input);

        // Fill out form
        var session_data_string = JSON.stringify({'SESSION_DATA':data_obj});

        assignmentId_input.value = assignmentId;
        submission_data_input.value = session_data_string;


        var currently_debugging = window.location.href.includes('localhost:');

        if (currently_debugging === false){
            submission_form.submit();
        }
        else{
            console.log('Currently on localhost; not submitting to turk');
        }

    }

    static get_workerId_from_url(url){
        var workerId = this._extract_url_string(url, 'workerId', 'workerId_not_found');
        console.log('workerId:', workerId);
        return workerId
    }

    static get_assignmentId_from_url(url){
        var assignmentId = this._extract_url_string(url, 'assignmentId', 'assignmentId_not_found');
        console.log('assignmentId', assignmentId);

        return assignmentId
    }

    static get_hitId_from_url(url){
        var hitId = this._extract_url_string(url, 'hitId', 'hitId_not_found');
        console.log('hitId', hitId);
        return hitId
    }

    static _extract_url_string(url, key, defaultValue){
        var name = key;
        key = key.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
        var regexS = "[\\?&]" + key + "=([^&#]*)";
        var regex = new RegExp(regexS);
        var results = regex.exec(url) || ["", defaultValue];

        return results[1]
    }

    static detect_previewer(url){
        /*
        Detect if the current url reflects the one given to a previewer.
        return: bool
         */

        let in_preview_mode;

        if (window.location.href.indexOf('localhost') !== -1) {
            // It's a developer running this on his/her machine; disable preview mode
            in_preview_mode = false;
        }
        else {
            // It's a live human viewing the page in preview mode on the Mechanical Turk Website
            in_preview_mode = assignmentId === 'assignmentId_not_found' || assignmentId === 'ASSIGNMENT_ID_NOT_AVAILABLE';
        }

        return in_preview_mode
    }

    static detect_sandbox(url){
        /*
        Detect if the current url reflects the one given to a subject using Mechanical Turk in sandbox mode.
        return: bool
         */
        // todo:
        let sandbox = false;
        return sandbox


    }

}


////////// IMPORT from /common/subject_action.js//////////
class ActionListenerClass {
    constructor(track_mouseclick, track_keypress, ) {
        /*
        track_mouseclick: bool
        track_keys: bool
        */

        this._resolveFunc;
        this._errFunc;

        var _this = this;

        this.listening_for_keypress = false;
        this.listening_for_mouse = false;

        this.actionCentroids = [];
        this.actionRadii = [];

        this.handleKeyPressEvent = function (event) {
            if (_this.listening_for_keypress !== true) {
                return
            }

            var actionIndex = _this.key2actionIndex[event.key];
            if (actionIndex === undefined) {
                // Invalid keypress
                return
            }

            _this.listening_for_keypress = false;
            _this._resolveFunc({
                'actionIndex': actionIndex,
                't': performance.now(),
            })
        };

        this.handleMouseEvent = function (event) {
            if (_this.listening_for_mouse === false){
                return
            }

            var x = event.pageX - _this.leftBound;
            var y = event.pageY - _this.topBound;
            var inside = false;

            for (var i = 0; i < _this.actionCentroids.length; i++) {
                inside = check_if_inside_circle(
                    x,
                    y,
                    _this.actionCentroids[i][0],
                    _this.actionCentroids[i][1],
                    _this.actionRadii[i]);
                if (inside === true) {
                    _this.listening_for_mouse = false;
                    _this._resolveFunc({
                        'actionIndex': i,
                        't': performance.now(),
                        'mouse_x': x,
                        'mouse_y': y
                    })
                }
            }
        };

        if (track_keypress === true){
            window.addEventListener('keypress', this.handleKeyPressEvent)
        }
        if (track_mouseclick === true){
            window.addEventListener('mouseup', this.handleMouseEvent)
        }
    }

    Promise_get_subject_mouseclick_response(xy_centroids, diameterPixels, timeout_msec, bounds) {

        this.leftBound = bounds['leftBound'];
        this.rightBound = bounds['rightBound'];
        this.topBound = bounds['topBound'];
        this.bottomBound = bounds['bottomBound'];


        this.actionRadii = [];
        this.actionCentroids = [];


        for (var i = 0; i < xy_centroids.length; i++) {
            this.actionCentroids.push([xy_centroids[i][0], xy_centroids[i][1]]);
            this.actionRadii.push(diameterPixels[i] / 2)
        }

        this.key2actionIndex = key2actionIndex;
        this.listening_for_mouse = true;
        var _this = this;
        var choice_promise = new Promise(function (resolve, reject) {
            _this._resolveFunc = resolve;
            _this._errFunc = reject
        });

        if (timeout_msec > 0){
            choice_promise = Promise.race([choice_promise, timeout(timeout_msec)])
        }

        return choice_promise
    }

    Promise_get_subject_keypress_response(key2actionIndex, timeout_msec) {

        this.key2actionIndex = key2actionIndex;
        var _this = this;
        this.listening_for_keypress = true;
        var choice_promise = new Promise(function (resolve, reject) {
            _this._resolveFunc = resolve;
            _this._errFunc = reject
        });

        if (timeout_msec > 0){
            choice_promise = Promise.race([choice_promise, timeout(timeout_msec)])
        }

        return choice_promise
    }


    close_listeners() {
        if (this.track_mouseclick === true){
            window.removeEventListener('mouseup', this.handleMouseEvent)
        }

        if (this.track_keypress === true){
            window.removeEventListener('keypress', this.handleKeyPressEvent)
        }
    }
}


function timeout(timeoutMsec) {
    return new Promise(
        function (resolve, reject) {
            var timer_return = function () {
                resolve({
                    "actionIndex": -1,
                    'timestamp': performance.now(),
                })
            };
            setTimeout(timer_return, timeoutMsec)
        })
}


function check_if_inside_circle(x, y, xc, yc, r) {
    var dxs = Math.pow(x - xc, 2);
    var dys = Math.pow(y - yc, 2);

    if ((dxs + dys) <= Math.pow(r, 2)) {
        return true
    } else {
        return false
    }
}




async function run_subtasks(subtask_sequence){
    /*
    subtask_sequence: Array of Objects, which detail the subtasks which will be run

    This function returns a list of returns from "run_binary_sr_trials". It allows the caller to request that multiple
    subtasks be run back-to-back.

    Between each subtask, a "splash" screen appears in which the subject is informed the last subtask has concluded.

    If a subtask is to fail, for some reason, this function concludes early, and returns the behavioral data for trials
    that have been completed so far. It also attaches the error message which was associated with the error.
     */

    var nsubtasks = subtask_sequence.length;
    var return_values = {'data':[]};
    var playspace_size_pixels = infer_canvas_size();
    try {
        for (var i_subtask = 0; i_subtask < nsubtasks; i_subtask++) {
            var cur_subtask = subtask_sequence[i_subtask];
            var cur_image_url_sequence = cur_subtask['image_url_seq'];
            var cur_label_sequence = cur_subtask['label_seq'];
            var cur_stimulus_duration_msec = cur_subtask['stimulus_duration_msec'];
            var cur_reward_duration_msec = cur_subtask['reward_duration_msec'];
            var cur_punish_duration_msec = cur_subtask['punish_duration_msec'];
            var cur_choice_duration_msec = cur_subtask['choice_duration_msec'];
            var cur_post_stimulus_delay_duration_msec = cur_subtask['post_stimulus_delay_duration_msec'];

            var cur_session_data = await run_binary_sr_trials(
                cur_image_url_sequence,
                cur_label_sequence,
                cur_stimulus_duration_msec,
                cur_reward_duration_msec,
                cur_punish_duration_msec,
                cur_choice_duration_msec,
                cur_post_stimulus_delay_duration_msec,
                playspace_size_pixels);
            return_values['data'].push(cur_session_data);

            // Run the "end of subtask" splash screen if there are tasks that remain after this one
            if ((i_subtask + 1) < (nsubtasks)){
                await inter_subtask_splash_screen(playspace_size_pixels)
            }
        }

        await provide_session_end(return_values['data'])

    }
    catch(error){
        console.log(error);
        return_values['error'] = error;
    }

    return return_values
}


async function run_binary_sr_trials(
    image_url_sequence,
    label_sequence,
    stimulus_duration_msec,
    reward_duration_msec,
    punish_duration_msec,
    choice_duration_msec,
    post_stimulus_delay_duration_msec,
    size,
){

    /*
    Core function for getting behavioral data on a binary-SR task from a human subject.

    image_url_sequence: [t]
    label_sequence: [t]. 0 or 1.
    stimulus_duration_msec: ()
    reward_duration_msec: ()
    punish_duration_msec: ()
    choice_duration_msec: ()
    post_stimulus_delay_duration_msec: ()
    size: () in pixels
     */

    var diameter_pixels = size * 0.25;

    var session_data = {};
    session_data['perf'] = [];
    session_data['action'] = [];
    session_data['reaction_time_msec'] = [];
    session_data['rel_timestamp_start'] = []; // The time the subject engaged the fixation button; is relative to the start time of calling this function
    session_data['rel_timestamp_stimulus_on'] = [];
    session_data['rel_timestamp_stimulus_off'] = [];
    session_data['rel_timestamp_choices_on'] = [];
    session_data['trial_number'] = [];

    // Pre-buffer images
    var trial_images = new ImageBufferClass;
    for (var i_image = 0; i_image < image_url_sequence.length; i_image++){
        await trial_images.get_by_url(image_url_sequence[i_image]);
    }

    // Begin tracking actions
    var action_recorder = new ActionListenerClass(false, true);

    // Iterate over trials
    var canvases = await initialize_sr_task_canvases(size);

    for (var i_trial = 0; i_trial < image_url_sequence.length; i_trial++){
        // Buffer stimulus
        var current_image = await trial_images.get_by_url(image_url_sequence[i_trial]);
        await draw_image(canvases['stimulus_canvas'], current_image, size/2, size/2, diameter_pixels);

        // Run trial initiation
        await display_canvas_sequence([canvases['blank_canvas'], canvases['fixation_canvas']], [0, 0]);
        var fixation_outcome = await action_recorder.Promise_get_subject_keypress_response({' ':-1});

        // Run stimulus
        var _stimulus_seq = undefined;
        var _t_seq = undefined;
        if (post_stimulus_delay_duration_msec > 0){
            // Insert delay before showing choices
            _stimulus_seq = [canvases['fixation_canvas'], canvases['stimulus_canvas'], canvases['blank_canvas'], canvases['choice_canvas']];
            _t_seq = [0, stimulus_duration_msec, post_stimulus_delay_duration_msec, 0]
        }
        else{
            // No delay before showing choices
            _stimulus_seq = [canvases['fixation_canvas'], canvases['stimulus_canvas'], canvases['choice_canvas']];
            _t_seq = [0, stimulus_duration_msec, 0]
        }
        var timestamp_stimulus = await display_canvas_sequence(_stimulus_seq, _t_seq);

        // Show choices and wait for response
        var choice_outcome = await action_recorder.Promise_get_subject_keypress_response({'f':0, 'j':1}, choice_duration_msec);
        var reaction_time_msec = choice_outcome['t'] - timestamp_stimulus[timestamp_stimulus.length-1];

        // Evaluate choice
        var perf = undefined;
        var cur_label = label_sequence[i_trial];
        var action = choice_outcome['actionIndex'];
        if (action === -1){
            // Timed out
            perf = 0
        }
        else if (action === cur_label){
            perf = 1
        }
        else{
            perf = 0
        }

        // Provide visual feedback, and apply a timeout
        var timestamp_feedback = undefined;
        if (perf === 0){
            timestamp_feedback = await display_canvas_sequence([canvases['choice_canvas'], canvases['punish_canvas'], canvases['blank_canvas']], [0, punish_duration_msec, 0]);
        }
        else if (perf === 1){
            timestamp_feedback = await display_canvas_sequence([canvases['choice_canvas'], canvases['reward_canvas'], canvases['blank_canvas']], [0, reward_duration_msec, 0]);
        }

        // Record outcomes
        session_data['perf'].push(perf);
        session_data['action'].push(action);
        session_data['reaction_time_msec'].push(Math.round(reaction_time_msec));
        session_data['rel_timestamp_start'].push(Math.round(fixation_outcome['t'])); // The time the subject engaged the fixation button; is relative to the start time of calling this function
        session_data['rel_timestamp_stimulus_on'].push(Math.round(timestamp_stimulus[1]));
        session_data['rel_timestamp_stimulus_off'].push(Math.round(timestamp_stimulus[2]));
        session_data['rel_timestamp_choices_on'].push(Math.round(timestamp_stimulus[timestamp_stimulus.length-1]));
        session_data['trial_number'].push(i_trial);
    }

    // Delete canvases
    canvases['fixation_canvas'].remove();
    canvases['stimulus_canvas'].remove();
    canvases['reward_canvas'].remove();
    canvases['punish_canvas'].remove();
    canvases['choice_canvas'].remove();
    canvases['blank_canvas'].remove();

    // Remove event listeners from window
    action_recorder.close_listeners();
    delete trial_images.cache_dict;

    return session_data
}

async function provide_session_end(session_data){
    var perf_per_subtask = [];
    for (let i_subtask = 0; i_subtask < session_data.length; i_subtask++){
        let cur_data = session_data[i_subtask];
        perf_per_subtask.push(MathUtils.mean(cur_data['perf']));
    }
    var grand_mean = MathUtils.mean(perf_per_subtask);
    var playspace_size_pixels = infer_canvas_size();
    await congratulations_screen(playspace_size_pixels, grand_mean)
}

async function congratulations_screen(size, mean_perf){
    /*
    Creates and displays a div informing the subject they are finished with the HIT, and they can press "space" to submit.
    size: () of canvas, in units of pixels
    mean_perf: (), from [0, 1]
     */

    let mean_perf_percentage = Math.round(mean_perf * 100);

    var splash1_canvas = create_canvas('splash1_canvas', size, size);
    var font_size = (size * 0.05).toString();
    var font = font_size+'px Times New Roman';

    function componentToHex(c) {
        var hex = c.toString(16);
        return hex.length === 1 ? "0" + hex : hex;
    }

    function rgbToHex(r, g, b) {
        return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
    }

    function color_interpolation(performance){
        /*
        performance: () between [0, 100]
        Returns a color hex code based on performance, from fully red (50 performance or below) to fully green (100 performance)
         */
        var green = Math.min(Math.max(0, 2 * performance/100 - 1), 0.8);
        var red = 0;
        var blue = 0;
        return rgbToHex(Math.round(red * 255), Math.round(green * 255), Math.round(blue * 255));
    }

    var average_color = color_interpolation(mean_perf);

    var total_pbar_width = 0.6;
    var filled_pbar_width = total_pbar_width * (mean_perf);
    await draw_text(splash1_canvas, 'Thank you for your work!', font, 'white', size/2, size * 0.3, 'center');
    await draw_rectangle(splash1_canvas, size*0.5, size * 0.5, size * total_pbar_width, size * 0.15, '#DCDCDC', 1);
    await draw_rectangle(splash1_canvas, size*(1 - total_pbar_width)/2 + size*(filled_pbar_width/2), size * 0.5, size * filled_pbar_width, size * 0.15, '#66ff33', 0.8);
    await draw_text(splash1_canvas, 'Score: '+mean_perf_percentage.toString()+'%', font, 'white', size/2, size * 0.5, 'center');

    //await draw_text(splash1_canvas, 'Your best performance was ' + best_perf.toString()+'%', font, high_color, size/2, size * 0.3);
    //await draw_text(splash1_canvas, 'Your worst performance was ' + worst_perf.toString()+'%', font, low_color, size/2, size * 0.4);
    await draw_text(splash1_canvas, 'Press space to submit.', font, '#66ff33', size/2, size * 0.65, 'center');

    await display_canvas_sequence([splash1_canvas], [0]);
    var action_recorder = new ActionListenerClass(false, true);

    await timeout(500);
    await action_recorder.Promise_get_subject_keypress_response({' ': 0}, 10000);
    splash1_canvas.remove()
}

async function inter_subtask_splash_screen(size){
    /*
    Displays a series of canvases informing the subject that the current task has ended, and a new one will begin.
    Requires that the subject press "b" to continue, after a timeout.
     */

    var timeout_msec = 3000;

    var splash1_canvas = create_canvas('splash1_canvas', size, size);
    var splash2_canvas = create_canvas('splash2_canvas', size, size);

    var ctx = splash1_canvas.getContext("2d");
    var font = '30px Times New Roman';
    var color = 'white';
    var text_align = 'center';
    var string1 = 'End of current task. A new task will start in 5 seconds.';
    var string2 = 'Press "b" on your keyboard to continue!';
    ctx.font = font;
    ctx.fillStyle = color;
    ctx.textAlign = text_align;
    ctx.fillText(string1, size/2, size*0.4);

    ctx = splash2_canvas.getContext("2d");
    ctx.font = font;
    ctx.fillStyle = color;
    ctx.textAlign = text_align;
    ctx.fillText(string1, size/2, size*0.4);

    ctx.font = font;
    ctx.fillStyle = "#66ff33";
    ctx.textAlign = text_align;
    ctx.fillText(string2, size/2, size*0.55);

    set_canvas_level(splash1_canvas, 100);
    await display_canvas_sequence([splash1_canvas, splash2_canvas], [timeout_msec, 0]);
    var action_recorder = new ActionListenerClass(false, true);
    await action_recorder.Promise_get_subject_keypress_response({'b': 0});

    splash1_canvas.remove();
    splash2_canvas.remove();
}


async function initialize_sr_task_canvases(size){
    var width = size;
    var height = size;
    var canvases = {};

    // Create fixation canvas
    canvases['fixation_canvas'] = create_canvas('fixation_canvas', width, height);
    await draw_dot_with_text(canvases['fixation_canvas'], 'Press space', width*0.5, height*0.75, size * 0.15, "white", 1);
    await draw_dot_with_text(canvases['fixation_canvas'], '', width*0.5, height*0.5, Math.max(10, size * 0.01), "black", 1);
    // Create stimulus canvas
    canvases['stimulus_canvas'] = create_canvas('stimulus_canvas', width, height);

    // Create reward canvas (green square)
    canvases['reward_canvas'] = create_canvas('reward_canvas', width, height);
    await draw_rectangle(
        canvases['reward_canvas'],
        width * 0.5,
        height*0.5,
        width * 1/3,
        height * 1/3,
        "#00cc00",
        0.5);

    // Create punish canvas (black square)
    canvases['punish_canvas'] = create_canvas('punish_canvas', width, height);
    await draw_rectangle(
        canvases['punish_canvas'],
        width * 0.5,
        height*0.5,
    width * 1/3,
        height * 1/3,
        "black",
        0.8);

    // Create choice canvas
    canvases['choice_canvas'] = create_canvas('choice_canvas', width, height);
    await draw_dot_with_text(canvases['choice_canvas'], 'F', width*0.25, height*0.75, size * 0.1, "white", 1);
    await draw_dot_with_text(canvases['choice_canvas'], 'J', width*0.75, height*0.75, size * 0.1, "white", 1);
    canvases['blank_canvas'] = create_canvas('blank_canvas', width, height);

    return canvases
}


    </script>

    <script>

        // Hardcoded experimental parameters
        var stimulus_duration_msec = 200;
        var reward_duration_msec = 100;
        var punish_duration_msec = 1000;
        var choice_duration_msec = 5000;
        var post_stimulus_delay_duration_msec = 0;

        // Assemble task info, randomly on-load
        function generate_subtask_sequence(train_url_sequence, train_label_sequence, test_pool_urls_0, test_pool_urls_1, ntest){
            /*
            train_url_sequence: Array of urls.
            train_label_sequence: Array of labels (0 or 1).
            test_pool_urls_0: Array of urls to class "0" test images. Has at least ntest/2 entries.
            test_pool_urls_1: Array of urls to class "1" test images. Has at least ntest/2 entries.
            ntest: an even Integer (e.g. 0, 2, 4...)

            Function for dynamically populating the test trials for a given subtask.
            The test trials are sampled evenly; each class is represented evenly. Images are sampled without replacement.

            Returns an Object which is an appropriate element of the Array that can be fed to run_subtasks(*)
             */
            let image_url_sequence = [... train_url_sequence];
            let label_sequence = [... train_label_sequence];


            // Randomly sample the label sequence for the test phase, evenly populating the test phase with each category.
            let test_label_sequence = new Array(ntest/2).fill(0);
            test_label_sequence.push(... new Array(ntest/2).fill(1));
            test_label_sequence = MathUtils.permute(test_label_sequence);

            // Randomly permute the test pools
            test_pool_urls_0 = MathUtils.permute(test_pool_urls_0);
            test_pool_urls_1 = MathUtils.permute(test_pool_urls_1);

            for (let i_test_trial=0; i_test_trial < ntest; i_test_trial++){
                let _cur_label = test_label_sequence[i_test_trial];
                if (_cur_label === 0){
                    // Attach a sample from class 0
                    image_url_sequence.push(test_pool_urls_0.shift());
                    label_sequence.push(_cur_label);
                }
                else{
                    // Attach a sample from class 1
                    image_url_sequence.push(test_pool_urls_1.shift());
                    label_sequence.push(_cur_label);
                }
            }

            // Randomly flip the label assignments
            if (Math.random() < 0.5){
                // Execute flip
                const flipped_label_sequence = [];
                for (let i_trial = 0; i_trial < label_sequence.length; i_trial++){
                    flipped_label_sequence.push(1 - label_sequence[i_trial])
                }
                label_sequence = [... flipped_label_sequence];
                console.log('Flipped labels')
            }

            return {
                'image_url_seq':image_url_sequence,
                'label_seq':label_sequence,
                'stimulus_duration_msec':stimulus_duration_msec,
                'reward_duration_msec':reward_duration_msec,
                'punish_duration_msec':punish_duration_msec,
                'choice_duration_msec':choice_duration_msec,
                'post_stimulus_delay_duration_msec':post_stimulus_delay_duration_msec,
            }
        }

        // Run tasks
        let subtask_pool = [
            generate_subtask_sequence(['https://milresources.s3.amazonaws.com/Images/AbstractShapes/bluediamond.png', 'https://milresources.s3.amazonaws.com/Images/AbstractShapes/bluediamond.png', 'https://milresources.s3.amazonaws.com/Images/AbstractShapes/bluediamond.png', 'https://milresources.s3.amazonaws.com/Images/AbstractShapes/orangediamond.png'], [0, 0, 0, 1], ['https://milresources.s3.amazonaws.com/Images/AbstractShapes/bluediamond.png', 'https://milresources.s3.amazonaws.com/Images/AbstractShapes/bluediamond.png', 'https://milresources.s3.amazonaws.com/Images/AbstractShapes/bluediamond.png'], ['https://milresources.s3.amazonaws.com/Images/AbstractShapes/orangediamond.png', 'https://milresources.s3.amazonaws.com/Images/AbstractShapes/orangediamond.png', 'https://milresources.s3.amazonaws.com/Images/AbstractShapes/orangediamond.png'], 2),
generate_subtask_sequence(['https://milresources.s3.amazonaws.com/Images/AbstractShapes/bluediamond.png', 'https://milresources.s3.amazonaws.com/Images/AbstractShapes/bluediamond.png', 'https://milresources.s3.amazonaws.com/Images/AbstractShapes/bluediamond.png', 'https://milresources.s3.amazonaws.com/Images/AbstractShapes/orangediamond.png'], [0, 0, 0, 1], ['https://milresources.s3.amazonaws.com/Images/AbstractShapes/bluediamond.png', 'https://milresources.s3.amazonaws.com/Images/AbstractShapes/bluediamond.png', 'https://milresources.s3.amazonaws.com/Images/AbstractShapes/bluediamond.png'], ['https://milresources.s3.amazonaws.com/Images/AbstractShapes/orangediamond.png', 'https://milresources.s3.amazonaws.com/Images/AbstractShapes/orangediamond.png', 'https://milresources.s3.amazonaws.com/Images/AbstractShapes/orangediamond.png'], 2),
        ];

        let subtask_sequence = MathUtils.permute(subtask_pool);

        // Extract session info
        const url = window.location.href;
        var assignmentId = mechanical_turk_util_functions.get_assignmentId_from_url(url);
        var in_preview_mode = mechanical_turk_util_functions.detect_previewer(url);
        var in_sandbox = mechanical_turk_util_functions.detect_sandbox(url);

        // Execute the task
        (async function (){
            await run_instructions(document.getElementById('instructions_html').innerHTML, in_preview_mode);
            var session_data = await run_subtasks(subtask_sequence);
            await mechanical_turk_util_functions.submit_data(assignmentId, in_sandbox, session_data);
        }());

    </script>
</head>


